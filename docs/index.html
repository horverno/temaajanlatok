<!DOCTYPE html>
<html>
<title>Témaajánlatok</title>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@500;700&display=swap');
h2 {
  font-family: 'Roboto', sans-serif;
  color: #244339;
}
p {
  font-family: 'Roboto', sans-serif;
  padding-left: 20px;
}
b{
  color: #242943;
}

.accordion {
  background-color: #eee;
  color: #242943;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 20px;
  transition: 0.4s;
  font-family: 'Roboto', sans-serif;
}

.active{
  background-color: #f5f5f5;
  font-family: 'Roboto', sans-serif;
}
.accordion:hover {
  background-color: #f6f6f6;
  font-family: 'Roboto', sans-serif;
}

.panel {
  font-family: 'Roboto', sans-serif;
  padding: 0 18px;
  background-color: #fcfcfc;
  color: #5f647c;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}

body {
  max-width: 1200px;
  margin: auto;
  padding: 20px;
}

</style>
</head>
<body>

<h2>Témaajánlatok</h2>

<p>A címekre kattintva további információk jelennek meg. 
A témák programozáshoz kapcsolódnak és leginkább robotika, önvezető járművek, ROS, mesterséges intelligencia, C++, python, Linux ismereteket igényelnek. 
Utóbbiak minden témaleírásnál külön feltüntetve. Itt felsorolt <a href="#korabbi">korábbi témák továbbfejlesztése</a> lehetséges, egyeztessük emailben.</p>

<img src="img/infologo02.svg" />

<button class="accordion">Önvezető járművek útkeresése és tervezése ismert algoritmusok segítségével ROS 2-ben</button>
<div class="panel">
  <p>Az önvezető autózás dinamikusan növekvő területének egyik kulcsfontosságú kihívása az optimális
    útkeresés algoritmusának kiválasztása és alkalmazása a járművek számára. Az autonóm járművek
    hatékonyan kell navigálniuk változatos és gyakran előre nem látható környezeti kihívások között, ezáltal
    biztonságos és hatékony útvonalakat tervezve a cél eléréséhez.
    Az útkeresési probléma előfeltétele a statikus és dinamikus környezeti modell ismerete, melyben a
    részben vagy egészben ismert térkép alapján számítható az útvonal a jármú kinematikai tulajdonságai és
    egy előre definiált célfüggvény ismeretében.
    A projekt célja egy olyan útkeresési és tervezési rendszer kifejlesztése és implementálása, amely az A*
    (A-star), RRT (Rapidly-exploring Random Tree) vagy más, elterjedt algoritmusokra épít. A hallgató
    feladata az adott autonóm járműhöz egy hatékony és megbízható útvonaltervező rendszer kidolgozása,
    figyelembe véve a különböző környezeti tényezőket és akadályokat. Az elvárt eredmény egy olyan
    szoftver megvalósítása és kiértékelése, amely lehetővé teszi az autonóm járművek számára, hogy adaptív
    és rugalmas módon válasszák ki az optimális útvonalat, hogy hatékonyan és biztonságosan navigáljanak a
    változatos közlekedési környezetben. A munka részét képezi a modern útkeresési módszereket feltáró
    irodalomkutatás, a módszerek kvalitatív és kvantitatív összehasonlítása, és kitekintés a gyakorlatban
    használt algoritmusokra olyan valós autóipari felhasználásokban, mint pl. az automatikus parkolás vagy
    az akadályelkerülés (collision avoidance // safe corridor) a nagysebességű manőverek esetében.
    A feladat megoldásához a hallgató a Continental AI Development Center munkatársaitól kap segítséget.</p>
    <p>Autonóm járművek és robotok programozása tantárgy idevágó tananyagrésze: <a href="https://sze-info.github.io/ajr/tervezes/">sze-info.github.io/ajr/tervezes/</a></p>
  <p><img src="https://sze-info.github.io/ajr/tervezes/params_en01.svg" width="80%" /></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> ROS2 Humble</li>
  </ul>
</div>


<button class="accordion">2D és 3D klaszterezési algoritmusok implementációja, felhasználása LIDAR adatokra</button>
<div class="panel">
  <p>A klaszterezés egy olyan dimenziócsökkentő, csoportosító eljárás, amellyel több dimenziós adatpontok homogén csoportokba sorolását, klasszifikálnását jelenti. Jelen esetben az adatpontok alatt 2D és 3D LIDAR szenzoradatokat értünk. 
    A bemeneti adatokból hasonlósági alapon kell megállapítani a klasztereket, illetve megkülönböztetni a többi klaszter elemeitől. A csoportosítás alapját különböző távolság- vagy hasonlóságmértékek képezik. 
    Az általános célú (k-means, MeanShift, DBSCAN, stb.) algoritmusok jellemző kimenetéhez képest a felismerendő klaszterek speciális alakúak (például hosszú egyenesek vagy görbék). 
    Ez azt is jelenti, hogy a mi feladatainkra csak részben működnek eredményesen. Cél tehát, hogy a speciális alakú felismerendő objektumokra saját, új algoritmus kerüljön kifejlesztésre. 
    Inspirációként természetesen célszerű a jelenlegi általános célú klaszterező algoritmusokat használni. A programozás C++ vagy python nyelven készüljön. 
    A teszteléshez publikus adatokat (<a href="https://jkk-research.github.io/#datasets">jkk-research.github.io/#dataset</a>) és kérésre külön méréseket is tudunk biztosítani. A feladat része több elérhető eljárással (k-means, MeanShift, DBSCAN, stb.) összevetni a saját algoritmust. Az összehasonlítás térjen ki többek között a pontosságra, futási sebességre, algoritmikus komplexitásra. A program ROS node legyen, tehát tudjon ROS topicra feliratkozni és publikálni, real-time, 20 Hz futási sebességgel.
    Hasonló általános célú algoritmusok leírása itt található:  <a href="https://en.wikipedia.org/wiki/Cluster_analysis">en.wikipedia.org/wiki/Cluster_analysis</a></p>
  <p><img src="img/cluster01.png" width="80%" /></p>
  <p><img src="img/cluster02dbscan.gif" /></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>


<button class="accordion">Valós robotra történő algoritmusimplementáció, verseny céllal</button>
<div class="panel">
  <p>Az egyetemünk tulajdonában lévő Wheeltec / Roboworks Rosbot mini egy Ackermann robot, amely LIDAR-ral, kamerával, IMU-val ellátott. A robot Nvidia Jetson beágyazott vezérlővel rendelkező ROS támogatott. 
    A gyártó nyílt forráskódú algoritmusokkal ellátta, így ROS rendszerben alkalmas sebesség és kormányszög alapú vezérlésre, valamint a pozícióról is     meglehetősen pontos becsléssel rendelkezik. ROS-ben driver szinten hozzáférhetőek a szenzorok. A feladat erre a robotra
    történő algoritmus implementáció. 
    Részfeladatok:
    <ul>
      <li>Roboworks Rosbot mini megismerése (SHH kezelés, ROS alapok elsajátítása)</li>
      <li>A meglévő (sajnos egyáltalán nem jól dokumentált) package-k dokumentálása még az első félév során</li>
      <li>A gazebo szimulátor (https://github.com/sze-info/racecar_gazebo) megismerése, összevetése a valós robottal. Ha
        szükséges javaslatok felvetése a javításra.</li>
      <li>Egyszerű fal követő megoldás implementálása, amely képes körpályán versenyezni. Összevetése a gyári megvalósítással (simple_follower /
          laser_follower) illetve a középiskolás verseny példamegoldásával: <a href="https://robotverseny.github.io/megoldas_zala23/">robotverseny.github.io/megoldas_zala23</a></li>
      <li>A fal követő megoldás továbbfejlesztése <a href="https://f1tenth.org/">F1tenth</a> megoldásokkal: <a href="https://robotverseny.github.io/#szabalyzat">robotverseny.github.io/#szabalyzat</a></li>
    </ul>
    A robotot hosszabb-rövidebb ideig kölcsönadható a dolgozat ideje alatt, ha az egytemen történő munka épp nem
    megoldható.</p>
  <p>
    <img src="https://raw.githubusercontent.com/robotverseny/robotverseny.github.io/main/img/2023_002.jpg" width="40%" />
    <img src="https://raw.githubusercontent.com/robotverseny/robotverseny.github.io/main/img/2023_001.jpg" width="40%" />
  </p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">Real-time ROS/ROS2 Neurális háló alapú, közlekedési célú mozgásbecslés</button>
<div class="panel">
  <p>A járművet körülvevő objektumok mozgásának prediktálása, becslése (esztimálása) az önvezető (autonóm) járművek fontos alfeladata. Jelenlegi tudásunk szerint ezt a feladatot kameraképből vagy LIDAR pontfelhőből neurális hálók segítségével lehet a leghatékonyabban megoldani. Erre megoldás lehet például az időbeliséget reprezentáló RNN (recurrent neural network) alkalmazása. </p>
  <p>
    A munka nem előzménynélküli, saját részmegoldások és egyéb források is elérhetőek:
    <iframe width="560" height="315" src="https://www.youtube.com/embed/OT_MxopvfQ0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </p>
  <p>Fontos, hogy real-time (20Hz) és ROS node megoldás fogadható csak el.</p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> Python</li>
    <li><b>A munka során meg kell ismerni:</b> TensorFlow / PyTorch, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>


<button class="accordion">Embszerű trajektória tervező C++ nyelven ROS kompatibiltással</button>
<div class="panel">
  <p>Embszerű trajektória tervező átültetése Simulinkból C++-ba, ROS-es validálás, kalibrálás</p>
  <p>Adott egy Simulink model, amely egy lokális trajektória tervezőt tartalmaz. Az érzékelt sávszél infók alapján kiszámol egy trajektóriát, amely alapján a jármű az úton képes haladni.
    A modell már létezik, azonban további funkciókat is hozzá lehet adni. A fő feladat ennek a trajektória tervezőnek a megértése, átemelése C++ kódba, majd validálás az eredeti tervezőhöz képest ROS-es szimulációban.   
    A végeredmény egy letisztult ROS node, amely egy sávtartó funkció részévé válik.</p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> C++</li>
    <li><b>A munka során meg kell ismerni:</b> ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>


<button class="accordion">Konvolúciós neurális háló-alapú vezethető útfelület meghatározás</button>
<div class="panel">
  <p>A vezethető útfelület észlelése mind az vezetéstámogatás, mind az önvezető járművek fontos alfeladata. Kameraképből a vezethető útfelület meghatározása mai tudásunk szerint leghatékonyabban neurális hálók segítségével lehet. A rendszer megköveteli az úthatár azonosítását és a környező akadályok, például járművek, gyalogosok, védőkorlátok és épületek felderítését. A fejlesztendő rendszer által észlelt eredmény felhasználható ütközések elkerülésére és az útvonal tervezésére. A feladat része, hogy ROS sensor_msgs/Image típusban érkező képből visualization_msgs/MarkerArray típusú üzenetben jelenítse meg az út szélét, átkonvertálva azt "bird eye view"-ba. A marker az út szélét jelző félpoligonokból álljon, lehetőleg egyszerűsített módon, kevés pontszámból álljon. A fejlesztendő algoritmussal szemben támasztott további követelmény a 20Hz-es feldolgozási idő. Mentett log adatok a fejlesztéshez publikusan elérhetőek (<a href="https://github.com/szenergy/szenergy-public-resources">github.com/szenergy/szenergy-public-resources </a>), de kérésre újakat is tudunk rögzíteni. </p>
  <p><iframe width="560" height="315" src="https://www.youtube.com/embed/hkLjQw2ZjWM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> Python</li>
    <li><b>A munka során meg kell ismerni:</b> TensorFlow / PyTorch, ROS / ROS2, Linux / Windows 11 WSLg</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>







<!-- Korábbi témaajánlatok -->
<!-- Korábbi témaajánlatok -->
<!-- Korábbi témaajánlatok -->
<!-- Korábbi témaajánlatok -->
<!-- Korábbi témaajánlatok -->
<!-- Korábbi témaajánlatok -->


<h2 style="margin-top:4cm;"><div id="korabbi">Korábbi témaajánlatok</div></h2>

<button class="accordion">Modern webtechnológiákra épülő robotvizualizáció</button>
<div class="panel">
  <p><b>Elvállalta: K. T. Előd</b></p>  
  <p>TypeScript, JavaScript, Node.js, yarn felhasználásával robotvizualizációs extension készítése Foxglove Studiohoz.</p>
  <p>Link: <a href="https://foxglove.dev/docs/studio/extensions/getting-started">foxglove.dev/docs/studio/extensions/getting-started</a></p>
  <p><img src="https://media.githubusercontent.com/media/foxglove/studio/main/resources/screenshot.png" width="60%"></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> </li>
    <li><b>A munka során meg kell ismerni:</b> TypeScript, JavaScript, Node.js, yarn</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">Kamera alapú úthiba és kátyú detekció </button>
<div class="panel">
  <p><b>Elvállalta: Á. Bálint</b></p>  
  <p>Kamera mérésekből megállapítani a kátyúkat (neurális háló segítségével) majd ezt transzformálni (pl LIDAR alapon). ROS megoldás az elvárt.</p>
  <p><img src="img/uthiba02.png" width="1000px" /></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">ROS környezetben LIDAR alapú úthiba és kátyú detekció </button>
<div class="panel">
  <p><b>Elvállalta: T. István</b></p>  
  <p>LIDAR mérésekből megállapítani a kátyúkat (neurális háló segítségével)</p>
  <p><img src="img/uthiba01.png" width="1000px" /></p>
  <p><iframe width="560" height="315" src="https://www.youtube.com/embed/1IWXO0vvmO8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>


<button class="accordion">LIDAR intenzitás alapú sávdetekció </button>
<div class="panel">
  <p><b>Elvállalta: J. Mátyás</b></p>  
  <p>LIDAR mérésekből megállapítani a formgalmi sávokat real-time, 20 Hz. A hallgató feladata, hogy ROS / ROS2 kompatibilitással C++ programot (node-ot) készítsen sávdetektálásra. További lehetőség, hogy az algoritmus deszkamodelljét Python nyelven dolgozza ki. Az algoritmus bemenete sensor_msgs/PointCloud2 típusú LIDAR pontfelhő, amely városi vagy közúti környezetben készült és tartalmaz nyers sávadatokat. A kimenet olyan visualization_msgs/MarkerArray, amely a nyers sávadatokat már feldolgozott formában képes hirdetni, vizualizálni. A munkához felhasználható bármely nyílt forráskódú megoldás, forrásmegjelöléssel. A munka dokumentálása, a konzultációk történjen GitHub alapokon. Kiinduláshoz használható az egyetemi dataset: https://jkk-research.github.io/#dataset, de kérésre rögzítünk újakat.</p>
  <p><img src="https://raw.githubusercontent.com/wiki/szenergy/szenergy-public-resources/img/rviz01b.png" width="1000px" /></p>
  <p><iframe width="560" height="315" src="https://www.youtube.com/embed/1IWXO0vvmO8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>


<button class="accordion">Emberszerű trajektória tervező hangolása tanuló algoritmus segítségével</button>
<div class="panel">
  <p><b>Elvállalta: V. Máté</b></p>
  <p>Egy meglévő MATLAB kód alapján egy trajektória tervezőhöz egy vezető modell elkészítése. A modell alapjai már elkészültek, ezt lehet továbbfejleszteni úgy, hogy mindez egy neurális hálót tartalmazzon. 
  </p>
  
  <p>
    A piacon elérhető vezetéstámogató és részben automatizált vezetési rendszerek alapvető eleme a sávtartó funkció.
    Azonban ezen funkciók nagyban leegyszerűsített, és így az emberi vezetési stílustól eltérő viselkedést mutatnak. A dolgozat
    során cél:
    <ul>
      <li>Jól meghatározott forgalmi helyzetekben valódi sofőrök választott trajektóriáinak azonosítása.</li>
      <li>Egy vezetői matematikai modell létrehozása neurális háló (vagy más nemlineáris függvényreprezentáció) segítségével.</li>
      <li>A mérések és egy rendelkezésre álló trajektória segítségével a modell kalibrálása.</li>
      <li>A modell validálása erre szolgáló teszt adathalmazon.</li>
    A feladatot egy rendelkezésre álló feldolgozó és kiértékelő környezetben kell megvalósítani, a cél, hogy az elkészült
    algoritmus a MATLAB programmal kompatibilis legyen.
  </ul>
    
  A hálót valódi forgalmi környezetben felvett mérések alapján kell tanítani, majd másik (lineáris) vezetői modellel összehasonlítani. Meg kell határozni a háló típusát és paramétereit, implementálni (leginkább MATLAB-ban, akár beépített függvények használatával) majd tesztelni a felvett adatokon. Ehhez rendelkezésre áll egy szegmentáló és kiértékelő környezet, amelyet használni lehet / kell.
  </p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> Programozási ismeretek, neurális hálók</li>
    <li><b>A munka során meg kell ismerni:</b> MATLAB, TensorFlow / PyTorch, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>
<button class="accordion">Segway Loomo robotikai alkalmazásai</button>
<div class="panel">
  <p><b>Elvállalta: Cs. Cintia</b></p>
  <p>Az egyetem tulajdonában lévő robot különböző fejelsztési feladatai.</p>
  <p><img src="https://assets.segway-cdn.com/Product-Pictures/_product_full/loomo.png" /></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> Minimális Android fejlesztői ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> A dolgozathoz használható robot az egyetemé, nem lehet hazavinni, de munkaidőban itt végig elérhető</li>
  </ul>
</div>


<button class="accordion">ROS/ROS2 GUI kialakítása RVIZ/RVIZ2 pluginként</button>
<div class="panel">
  <p><b>Elvállalta: I. B.</b></p>
  <p>RVIZ/RVIZ2 plugin létrehozása Linux/Windows 11</p>
  <p><img src="img/rviz_gui01.png"></img></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek</li>
    <li><b>A munka során meg kell ismerni:</b> C++ / Python, ROS / ROS2, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">Autonóm modelljárművezérlés Robot Operating System (ROS) használatával</button>
<div class="panel">
  <p><b>Elvállalta: F. R.</b></p>
  <p>A feladat során a járműmodell egy szimulált környezetben különböző szenzorokra támaszkodva, a pillanatnyi helyzet és szenzoradatok alapján, feltérképezi a környezetét, majd az üzemmódjának megfelelően viselkedik. A fő funkció az autonóm üzemmód, melyben a jármű számára ismeretlen, teljesen új környezetben tud haladni, úgy, hogy nem tér le az útról és az azon található akadályokkal való találkozást elkerüli. Másodlagos feladat, hogy autonóm üzemmódba a jármű a legrövidebb idő alatt a legtöbb utat tegye meg, mint egy klasszikus versenyen. Emellett, a modern, az autonóm járművek képességeit próbára tevő, Shell Eco-marathon nevű verseny, új, autonóm járművekre kiírt feladatai közül képes legyen néhányat megoldani
    </p>
</div>

<button class="accordion"> Neurális hálóval / mesterséges intelligenciával támogatott sör főzés  </button>
<div class="panel">
  <p><b>Elvállalta: B. Sz</b></p>
  <p>A témaleírás kidolgozás alatt🍺</p>
  <p></p>
  <p></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozás alapismeretek, mesterséges intelligencia</li>
    <li><b>A munka során meg kell ismerni:</b> TensorFlow / PyTorch</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">Coverage path planning, gyakorlati megközelítésből</button>
<div class="panel">
  <p><b>Elvállalta: T. Tibor</b></p>
  <p>A feladat magában foglalja coverage path planning (CPP) algoritmusok megvalósítását és elemző összevetését, valamint a vonatkozó szakirodalom áttekintését is. A CPP algoritmusok térképek optimális bejárásának kérdéseivel foglalkoznak. A megvalósítás nyelve lehet python gay C++. Legalább két CPP algoritmus (pl. boustrophedon cellular decomposition coverage, iterative structured orientation coverage) megvalósítása a cél. Az algoritmusok occupancy grid map (foglatsági rács) reprezentációjú térképeken működjenek. A megvalósítás után az elemző összevetés térjen ki a megvalósított algoritmusok teljesítményére, számítási igényére, illetve nyelvekkel kapcsolatos megvalósíthatósági kérdésekre is. Amennyiben a munka során feltár lehetőségeket, tegyen javaslatot az algoritmusok optimalizációjával kapcsolatban is. A forráskódot publikus repository-n megosztani. Példa a lehetséges eredményre, kimenetre (ez MATLAB-ban készült):</p>
  <p><img src="img/coverage01.gif" /></p>
  
  <ul>
    <li><b>Szükséges elősimeretek:</b> Python, GitHub</li>
    <li><b>A munka során meg kell ismerni:</b> ROS / ROS2</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<button class="accordion">Openstreetmap data exploration Magyarország</button>
<div class="panel">
  <p><b>Elvállalta: Sz. Dávid</b></p>
  <p>Térképes adatvizualizációs technológiák Magyarországról pl: </p>
  <p><img src="https://raw.githubusercontent.com/njanakiev/openstreetmap-heatmap/master/assets/DE_biergarten_animation.gif" /></p>
  <p>Kiinduláshoz további példa <a href="https://atlo.team/telepulesnevek/">atlo.team/telepulesnevek</a> </p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> </li>
    <li><b>A munka során meg kell ismerni:</b> Python, Jupyter notebook, GitHub, Openstreetmap (opcionális webes formátumhoz további webes ismeretek)</li>
    <li><b>Egyéb fontos tudnivaló:</b> </li>
  </ul>
</div>

<button class="accordion">3D egyetemi campus létrehozása</button>
<div class="panel">
  <p><b>Elvállalta: K. Kíra</b></p>
  <p>LIDAR mérésekből az egyetem campusának 3D mesh létrehozás, openstreetmap-ra feltöltése (ez jelenleg is létezik, de elég pontatlannak tűnik, viszont vannak LIDAR méréseink, amivel ezt meg lehetne oldani) <a href="https://osmbuildings.org/?lat=47.69387&lon=17.62802&zoom=18.6&tilt=34&rotation=-28">osmbuildings.org</a>
    Első lépés itt a 3D point cloud létrehozása lenne. Ebben van egy kis tapasztalatunk, tudok segíteni, de internetről összeszedhető a tudás. Amit mi készítettünk egy zalai épületről az pl így néz ki:
    <iframe width="560" height="315" src="https://www.youtube.com/embed/MoGnmP2Gc6w" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> 
    Második lépés a pontfelhőből valamilyen mesh készítése akár "kézzel" akár automatikusan pl így: <a href="https://pointclouds.org/documentation/tutorials/greedy_projection.html">pointclouds.org</a>
    Aztán jó lenne egyszerűsíteni ezt a mesht, ha olyan bonyolutra sikerült, mint a fenti linken, primitívekkel (pl tégletest, henger)
    Ezután megismerni az OSM API-t 
    Pontosítani a jelenlegi ábrázolást és feltölteni</p>
  <p><iframe width="560" height="315" src="https://www.youtube.com/embed/kTf-VvokQH8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
  <ul>
    <li><b>Szükséges elősimeretek:</b> programozási ismeretek, 3D ismeretek (pl Blender)</li>
    <li><b>A munka során meg kell ismerni:</b> SVL simulator, GitHub</li>
    <li><b>Egyéb fontos tudnivaló:</b> -</li>
  </ul>
</div>

<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.maxHeight) {
      panel.style.maxHeight = null;
    } else {
      panel.style.maxHeight = panel.scrollHeight + "px";
    } 
  });
}
</script>

</body>
</html>
